import numpy as np
cimport numpy as np
from libc.math cimport sin, cos, fmod, pi, acos, atan2, atan, pow
from libc.complex cimport cexp as complex_exp
from .time import greenwich_mean_sidereal_time
from cython.parallel cimport prange


cdef double CC = 299792458.0
cdef c_km_s = CC/1e3

cpdef time_delay_geocentric(np.ndarray detector1, np.ndarray detector2, double ra, double dec, double time):
    """
    Calculate time delay between two detectors in geocentric coordinates based on XLALArrivaTimeDiff in TimeDelay.c

    Parameters
    ----------
    detector1: array_like
        Cartesian coordinate vector for the first detector in the geocentric frame
        generated by the Interferometer class as self.vertex.
    detector2: array_like
        Cartesian coordinate vector for the second detector in the geocentric frame.
        To get time delay from Earth center, use detector2 = np.array([0,0,0])
    ra: float
        Right ascension of the source in radians
    dec: float
        Declination of the source in radians
    time: float
        GPS time in the geocentric frame

    Returns
    -------
    float: Time delay between the two detectors in the geocentric frame

    """
    cdef double output, gmst, theta, phi, sintheta, costheta, sinphi, cosphi
    cdef double[:] detector_1_view = detector1
    cdef double[:] detector_2_view = detector2

    gmst = fmod(greenwich_mean_sidereal_time(time), 2 * pi)
    phi = ra - gmst
    theta = pi / 2 - dec
    sintheta = sin(theta)
    costheta = cos(theta)
    sinphi = sin(phi)
    cosphi = cos(phi)

    output = (
        (detector_2_view[0] - detector_1_view[0]) * sintheta * cosphi
        + (detector_2_view[1] - detector_1_view[1]) * sintheta * sinphi
        + (detector_2_view[2] - detector_1_view[2]) * costheta
    ) / CC
    return output


_GEOCENTER = np.zeros(3, dtype=float)


cpdef time_delay_from_geocenter(np.ndarray detector1, double ra, double dec, double time):
    """
    Calculate time delay between a detectors and the geocenter
    based on XLALArrivalTimeDiff in TimeDelay.c

    Parameters
    ----------
    detector1: array_like
        Cartesian coordinate vector for the first detector in the geocentric frame
        generated by the Interferometer class as self.vertex.
    ra: float
        Right ascension of the source in radians
    dec: float
        Declination of the source in radians
    time: float
        GPS time in the geocentric frame

    Returns
    -------
    float: Time delay between the two detectors in the geocentric frame

    """
    return time_delay_geocentric(detector1, _GEOCENTER, ra, dec, time)

cpdef time_delay_from_geocenter_given_gmst(np.ndarray detector, double ra, double dec, double[:] gmst):
    """
    Calculate time delay between two detectors in geocentric coordinates based on XLALArrivaTimeDiff in TimeDelay.c

    Parameters
    ----------
    detector: array_like
        Cartesian coordinate vector for the first detector in the geocentric frame
        generated by the Interferometer class as self.vertex.
    ra: float
        Right ascension of the source in radians
    dec: float
        Declination of the source in radians
    gmst: float
        GMST when signal is at geocenter

    Returns
    -------
    float: Time delay between the two detectors in the geocentric frame

    """
    cdef double theta, phi, sintheta, costheta, sinphi, cosphi
    cdef double[:] detector_1_view = detector
    cdef double[:] detector_2_view = _GEOCENTER
    output = np.zeros(len(gmst))
    cdef double[:] out_ = output

    theta = pi / 2 - dec
    sintheta = sin(theta)
    costheta = cos(theta)

    for ii in range(len(gmst)):
        phi = ra - gmst[ii]
        sinphi = sin(phi)
        cosphi = cos(phi)
        out_[ii] = (
            (detector_2_view[0] - detector_1_view[0]) * sintheta * cosphi
            + (detector_2_view[1] - detector_1_view[1]) * sintheta * sinphi
            + (detector_2_view[2] - detector_1_view[2]) * costheta
        ) / CC
    return output

_GEOCENTER = np.zeros(3, dtype=float)

cdef _vectors_for_polarization_tensor(double phi, double theta, double psi):
    r"""
    Compute the three vectors that can be used to construct the different
    population modes.

    .. math::

        m = (
            - \cos\theta \cos\phi \sin\psi + \sin\phi \cos\psi,
            - \cos\theta \sin\phi \sin\psi - \cos\phi \cos\psi,
            \sin\theta \sin\psi
        )

        n = (
            - \cos\theta \cos\phi \cos\psi - \sin\phi \sin\psi,
            - \cos\theta \sin\phi \cos\psi + \cos\phi \sin\psi,
            \sin\theta \cos\psi
        )
        
        \omega = m \cross n

    Parameters
    ----------
    phi
    theta
    psi

    Returns
    -------

    """
    cdef double cosphi, sinphi, costheta, sintheta, cospsi, sinpsi
    cdef int ii, jj

    cosphi = cos(phi)
    sinphi = sin(phi)
    costheta = cos(theta)
    sintheta = sin(theta)
    cospsi = cos(psi)
    sinpsi = sin(psi)
    m_view[0] = - costheta * cosphi * sinpsi + sinphi * cospsi
    m_view[1] = - costheta * sinphi * sinpsi - cosphi * cospsi
    m_view[2] = sintheta * sinpsi
    n_view[0] = - costheta * cosphi * cospsi - sinphi * sinpsi
    n_view[1] = - costheta * sinphi * cospsi + cosphi * sinpsi
    n_view[2] = sintheta * cospsi
    omega_view[0] = m_view[1] * n_view[2] - m_view[2] * n_view[1]
    omega_view[1] = m_view[2] * n_view[0] - m_view[0] * n_view[2]
    omega_view[2] = m_view[0] * n_view[1] - m_view[1] * n_view[0]


m = np.zeros(3)
n = np.zeros(3)
omega = np.zeros(3)
cdef double[:] m_view = m
cdef double[:] n_view = n
cdef double[:] omega_view = omega


cpdef _polarization_tensor(double[:, :] output_view, str mode):
    if mode == 'plus':
        _plus(output_view)
    elif mode == 'cross':
        _cross(output_view)
    elif mode == 'breathing':
        _breathing(output_view)
    elif mode == 'longitudinal':
        _longitudinal(output_view)
    elif mode == 'x':
        _x(output_view)
    elif mode == 'y':
        _y(output_view)
    else:
        raise ValueError("{} not a polarization mode!".format(mode))


cpdef get_polarization_tensor(double ra, double dec, double time, double psi, str mode):
    """
    Calculate the polarization tensor for a given sky location and time

    See Nishizawa et al. (2009) arXiv:0903.0528 for definitions of the polarisation tensors.
    [u, v, w] represent the Earth-frame
    [m, n, omega] represent the wave-frame
    Note: there is a typo in the definition of the wave-frame in Nishizawa et al.

    Parameters
    ----------
    ra: float
        right ascension in radians
    dec: float
        declination in radians
    time: float
        geocentric GPS time
    psi: float
        binary polarisation angle counter-clockwise about the direction of propagation
    mode: str
        polarisation mode

    Returns
    -------
    array_like: A 3x3 representation of the polarization_tensor for the specified mode.

    """
    cdef double gmst, phi, theta
    output = np.zeros((3, 3))
    cdef double[:, :] output_view = output

    gmst = fmod(greenwich_mean_sidereal_time(time), 2 * pi)
    phi = ra - gmst
    theta = pi / 2 - dec
    _vectors_for_polarization_tensor(phi, theta, psi)

    _polarization_tensor(output_view, mode)

    return output

cpdef get_time_dependent_polarization_tensor_given_gmst(double ra, double dec, np.ndarray gmst, double psi, str mode):
    """
    Calculate the polarization tensor for a given sky location and time

    See Nishizawa et al. (2009) arXiv:0903.0528 for definitions of the polarisation tensors.
    [u, v, w] represent the Earth-frame
    [m, n, omega] represent the wave-frame
    Note: there is a typo in the definition of the wave-frame in Nishizawa et al.

    Parameters
    ----------
    ra: float
        right ascension in radians
    dec: float
        declination in radians
    gmst: array_like
        array of gmst to compute polarization tensor
    psi: float
        binary polarisation angle counter-clockwise about the direction of propagation
    mode: str
        polarisation mode

    Returns
    -------
    array_like: A 3x3 representation of the polarization_tensor for the specified mode.

    """
    cdef double phi, theta
    cdef int nt = len(gmst)
    output = np.zeros((nt, 3, 3))
    cdef double[:, :, :] output_view = output

    theta = pi / 2 - dec

    for ii in range(nt):
        phi = ra - gmst[ii]
        _vectors_for_polarization_tensor(phi, theta, psi)
        _polarization_tensor(output_view[ii, :, :,], mode)
    return output

cpdef calculate_doppler_shifted_frequencies_given_gmst_array(np.ndarray f, double ra, double dec, double[:] gmst, double[:] rotation_velocity):
    cdef double[:,:] n = calculate_n_given_gmst_array(ra, dec, gmst)
    cdef int nf = len(n)
    cdef int ii
    f_obs = np.empty(nf)
    cdef double[:] f_obs_view = f_obs

    for ii in range(nf):
        n_dot_v = 0
        for kk in range(3):
            n_dot_v += n[ii, kk] * rotation_velocity[kk]
        f_obs_view[ii] = f[ii] * (1 + n_dot_v/CC)
    return f_obs

cpdef calculate_n_given_gmst_array(double ra, double dec, double[:] gmst):
    """
    Calculates the unit vector pointing towards a given sky location in equatorial coordinates, 
     for an array of Greenwich Mean Sidereal Time (GMST) values.

    Parameters:
    - ra (double): Right ascension of the sky location in radians.
    - dec (double): Declination of the sky location in radians.
    - gmst (double[:]): An array of GMST values in radians.

    Returns:
    - np.ndarray: A 2D array where each row represents the [x, y, z] components of the unit vector in the Earth's frame for each GMST value.
    """
    cdef int nt = len(gmst)
    n = np.empty((nt, 3))
    cdef double[:,:,:] n_ = n
    cdef int kk, ii
    cdef double[:] temp

    for kk in range(nt):
        temp = get_n_components(ra, dec, gmst[kk])
        for ii in range(3):
            n_[kk, ii] = temp[ii]
    return n

cpdef calculate_n(double ra, double dec, double time):
    """
    Calculate line-of-sight vector n
    
    Parameters
    ----------
    ra: float
        right ascension in radians
    dec: float
        declination in radians
    time: float
        geocentric GPS time

    Returns
    -------
    array-like: A 1x3 representation of line-of-sight direction vector
    """
    cdef double gmst
    cdef double[:] out = np.empty(3)

    gmst = fmod(greenwich_mean_sidereal_time(time), 2 * pi)
    out = get_n_components(ra, dec, gmst)
    return out

def get_n_components(double ra, double dec, double gmst):
    """
    Calculates the directional components of a unit vector pointing towards a given sky location in equatorial coordinates, corrected for the Greenwich Mean Sidereal Time (GMST).

    Parameters:
        ra (double): Right ascension of the sky location in radians.
        dec (double): Declination of the sky location in radians.
        gmst (double): Greenwich Mean Sidereal Time in radians at the moment of interest.

    Returns:
        np.ndarray[double, ndim=1]: A NumPy array containing the three components of the unit vector in the Earth's frame. The components correspond to [x, y, z] in the equatorial coordinate system, where:
            - x points towards the vernal equinox,
            - y is perpendicular to x in the plane of the equator, and
            - z points towards the north celestial pole.
    """
    cdef double phi, theta, sintheta, costheta, sinphi, cosphi
    cdef double[:] out = np.empty(3)
   
    phi = ra - gmst
    theta = pi / 2 - dec
    sintheta = sin(theta)
    costheta = cos(theta)
    sinphi = sin(phi)
    cosphi = cos(phi)
    out[0] = sintheta * cosphi
    out[1] = sintheta * sinphi
    out[2] = costheta
    return out
    
cpdef get_polarization_tensor_multiple_modes(double ra, double dec, double time, double psi, list modes):
    """
    Calculate the polarization tensor for a given sky location and time with
    multiple modes

    See Nishizawa et al. (2009) arXiv:0903.0528 for definitions of the polarisation tensors.
    [u, v, w] represent the Earth-frame
    [m, n, omega] represent the wave-frame
    Note: there is a typo in the definition of the wave-frame in Nishizawa et al.

    Parameters
    ----------
    ra: float
        right ascension in radians
    dec: float
        declination in radians
    time: float
        geocentric GPS time
    psi: float
        binary polarisation angle counter-clockwise about the direction of propagation
    modes: list
        List of the polarization modes

    Returns
    -------
    array_like: A 3x3 representation of the polarization_tensor for the specified mode.

    """
    cdef double gmst, phi, theta
    cdef double[:, :] output_view
    output = list()

    gmst = fmod(greenwich_mean_sidereal_time(time), 2 * pi)
    phi = ra - gmst
    theta = pi / 2 - dec
    _vectors_for_polarization_tensor(phi, theta, psi)

    for mode in modes:
        tensor = np.zeros((3, 3))
        output_view = tensor
        _polarization_tensor(output_view, mode)
        output.append(tensor)
    return output


cdef _plus(double[:, :] output):
    cdef int ii, jj

    for ii in range(3):
        output[ii][ii] = m_view[ii] * m_view[ii] - n_view[ii] * n_view[ii]
        for jj in range(ii):
            output[ii][jj] = m_view[ii] * m_view[jj] - n_view[ii] * n_view[jj]
            output[jj][ii] = output[ii][jj]


cdef _breathing(double[:, :] output):
    cdef int ii, jj

    for ii in range(3):
        output[ii][ii] = m_view[ii] * m_view[ii] + n_view[ii] * n_view[ii]
        for jj in range(ii):
            output[ii][jj] = m_view[ii] * m_view[jj] + n_view[ii] * n_view[jj]
            output[jj][ii] = output[ii][jj]


cdef _longitudinal(double[:, :] output):
    cdef int ii, jj

    for ii in range(3):
        output[ii][ii] = omega_view[ii] * omega_view[ii]
        for jj in range(ii):
            output[ii][jj] = omega_view[ii] * omega_view[jj]
            output[jj][ii] = output[ii][jj]


cdef _symmetric_response(double[:, :] output, double[:] input_1, double[:] input_2):
    cdef int ii, jj

    for ii in range(3):
        output[ii][ii] = 2 * input_1[ii] * input_2[ii]
        for jj in range(ii):
            output[ii][jj] = input_1[ii] * input_2[jj] + input_1[jj] * input_2[ii]
            output[jj][ii] = output[ii][jj]


cdef _cross(double[:, :] output):
    _symmetric_response(output, m_view, n_view)


cdef _x(double[:, :] output):
    _symmetric_response(output, m_view, omega_view)


cdef _y(double[:, :] output):
    _symmetric_response(output, n_view, omega_view)


cpdef three_by_three_matrix_contraction(np.ndarray x, np.ndarray y):
    """
    Doubly contract two 3x3 input matrices following Einstein summation.
    
    ..math::

        output = x_{ij} y_{ij}
    
    Parameters
    ----------
    x: array_like
        First input matrix
    y: array_like
        Second input matrix

    Returns
    -------
    output: float
        The contracted value

    """
    cdef double output = 0
    cdef double[:, :] x_view = x
    cdef double[:, :] y_view = y

    for ii in range(3):
        for jj in range(3):
            output += x_view[ii, jj] * y_view[ii, jj]
    return output

cpdef frequency_dependent_matrix_contraction(np.ndarray x, np.ndarray y):
    """
    For a list of frequencies, doubly contract two 3x3 input matrices following Einstein summation.
    
    ..math::

        output = x_{ij} y_{ij}
    
    Parameters
    ----------
    x: array_like
        Shape (n_freq, 3, 3) First input matrix, i.e. the (frequency-dependent) detector tensor.
    y: array_like
        Second input matrix, i.e. the polarization tensor, which has been shaped to be (n_freq, 3, 3)

    Returns
    -------
    output: array
        The array of contracted values

    """
    cdef int nf = x.shape[0]
    output = np.zeros(nf, dtype=complex)
    cdef double complex[:] output_ = output
    cdef double complex[:, :, :] x_view = x
    cdef double[:, :, :] y_view = y
    cdef int ii, jj

    for kk in range(nf):
        for ii in range(3):
            for jj in range(3):
                output_[kk] += x_view[kk, ii, jj] * y_view[kk, ii, jj]
    return output

cpdef detector_tensor(np.ndarray x, np.ndarray y):
    r"""
    Compute the detector tensor given the two unit arm vectors.
    
    .. math::

        d_{ij} = \frac{x_{i} x_{j} - y_{i} y_{j}}{2}

    Parameters
    ----------
    x: array_like
        The x-arm vector
    y: array_like
        The y-arm vector

    Returns
    -------
    output: array_like
        The 3x3 detector tensor

    """
    output = np.empty((3, 3))
    cdef double[:] x_view = x
    cdef double[:] y_view = y
    cdef double[:, :] output_ = output

    for ii in range(3):
        for jj in range(3):
            output_[ii, jj] = (x_view[ii] * x_view[jj] - y_view[ii] * y_view[jj]) / 2
    return output

cpdef time_and_frequency_dependent_detector_tensor_given_gmst(np.ndarray[np.float64_t, ndim=1] f, double ra, double dec, np.ndarray[np.float64_t, ndim=1] gmst, np.ndarray[np.float64_t, ndim=1] arm_vecx, np.ndarray[np.float64_t, ndim=1] arm_vecy, double f_fsr):
    """
    Constructs a frequency-dependent tensor representing the response, based on the detector's arm orientations and the source's sky position.
    Accounts only for the frequency-dependent effects of the arm lengths.

    Parameters:
    - f (np.ndarray[np.float64_t, ndim=1]): An array of frequencies at which the detector's response is being calculated
    - ra (double): Right ascension of the gravitational wave source in radians
    - dec (double): Declination of the gravitational wave source in radians
    - gmst (double[:]): Array of GMSTs corresponding to the times of `f` in the signal
    - arm_vecx (np.ndarray[np.float64_t, ndim=1]): The unit vector along the detector's x-arm, in the detector's frame
    - arm_vecy (np.ndarray[np.float64_t, ndim=1]): The unit vector along the detector's y-arm, in the detector's frame
    - f_fsr (double): The free spectral range of the detector

    Returns:
    - np.ndarray[np.complex128_t, ndim=3]: A 3D array where each element [k, i, j] represents the complex detector response at frequency f[k] due to a source at (ra, dec) at gmst[k]
    """    
    cdef int nf = f.shape[0]
    cdef np.float64_t[:] x_view = arm_vecx
    cdef np.float64_t[:] y_view = arm_vecy
    cdef double[:,:] x_ii_jj = np.empty((3, 3))
    cdef double[:,:] y_ii_jj = np.empty((3, 3))
    cdef np.float64_t[:] f_view = f
    cdef np.ndarray[np.complex128_t, ndim=3] output = np.empty((nf, 3, 3), dtype=complex)
    cdef np.complex128_t[:, :, :] output_ = output
    cdef np.complex128_t[:] Dx, Dy
    cdef int ii, jj, kk
    n = np.empty((nf, 3))
    cdef double[:,:] n_ = n
    cdef double[:] temp

    for kk in range(nf):
        temp = get_n_components(ra, dec, gmst[kk])
        for ii in range(3):
            n_[kk, ii] = temp[ii]

    Dx = time_and_frequency_dependent_projected_detector_function(f_view, n, x_view, f_fsr)
    Dy = time_and_frequency_dependent_projected_detector_function(f_view, n, y_view, f_fsr)

    for ii in range(3):
        for jj in range(3):
            x_ii_jj[ii, jj] = x_view[ii] * x_view[jj]
            y_ii_jj[ii, jj] = y_view[ii] * y_view[jj]

    for kk in range(nf):
        Dx_kk = Dx[kk]
        Dy_kk = Dy[kk]
        for ii in range(3):
            for jj in range(3):
                output_[kk, ii, jj] = Dx_kk * x_ii_jj[ii, jj] - Dy_kk * y_ii_jj[ii, jj]

    return output

cpdef frequency_dependent_detector_tensor(np.ndarray[np.float64_t, ndim=1] f, double ra, double dec, double time, np.ndarray[np.float64_t, ndim=1] arm_vecx, np.ndarray[np.float64_t, ndim=1] arm_vecy, double f_fsr):
    """
    Constructs a frequency-dependent tensor representing the response, based on the detector's arm orientations and the source's sky position.
    Accounts only for the frequency-dependent effects of the arm lengths.

    Parameters:
    - f (np.ndarray[np.float64_t, ndim=1]): An array of frequencies at which the detector's response is being calculated
    - ra (double): Right ascension of the gravitational wave source in radians
    - dec (double): Declination of the gravitational wave source in radians
    - time (double): GPS time
    - arm_vecx (np.ndarray[np.float64_t, ndim=1]): The unit vector along the detector's x-arm, in the detector's frame
    - arm_vecy (np.ndarray[np.float64_t, ndim=1]): The unit vector along the detector's y-arm, in the detector's frame
    - f_fsr (double): The free spectral range of the detector

    Returns:
    - np.ndarray[np.complex128_t, ndim=3]: A 3D array where each element [k, i, j] represents the complex detector response at frequency f[k] due to a source at (ra, dec)
    """    
    
    cdef int nf = f.shape[0]
    cdef np.float64_t[:] x_view = arm_vecx
    cdef np.float64_t[:] y_view = arm_vecy
    cdef double[:,:] x_ii_jj = np.empty((3,3))
    cdef double[:,:] y_ii_jj = np.empty((3,3))
    cdef np.float64_t[:] f_view = f
    cdef np.ndarray[np.complex128_t, ndim=3] output = np.empty((nf, 3, 3), dtype=complex)
    cdef np.complex128_t[:, :, :] output_ = output
    cdef np.complex128_t[:] Dx, Dy
    cdef int ii, jj, kk
    cdef double[:] n = calculate_n(ra, dec, time) 

    Dx = frequency_dependent_projected_detector_function(f_view, n, x_view, f_fsr) 
    Dy = frequency_dependent_projected_detector_function(f_view, n, y_view, f_fsr) 
    for ii in range(3):
        for jj in range(3):
            x_ii_jj[ii,jj] = x_view[ii] * x_view[jj] 
            y_ii_jj[ii,jj] = y_view[ii] * y_view[jj]

    for kk in range(nf):
        Dx_kk = Dx[kk]  
        Dy_kk = Dy[kk] 
        for ii in range(3):
            for jj in range(3):
                output_[kk, ii, jj] = Dx_kk * x_ii_jj[ii, jj] - Dy_kk * y_ii_jj[ii, jj]

    return output

cpdef time_and_frequency_dependent_projected_detector_function(double[:] f, double[:,:] n_vec, double[:] arm_vec, double f_fsr):
    """
    Computes eq. 5 in https://journals.aps.org/prd/pdf/10.1103/PhysRevD.96.084004 by
    projecting n onto the e basis vectors (arms unit vectors). 

    Parameters:
    - f (double[:]): An array of frequencies at which the detector's response is being calculated. Each `f` corresponds to a different time and line-of-sight n.
    - n_vec (double[:,:]): A 2D array where each row represents the unit vector pointing towards the source of the gravitational waves, in the detector's frame, at different times.
    - arm_vec (double[:]): The unit vector along the detector's arm, in the detector's frame.
    - f_fsr (double): The free spectral range of the detector

    Returns:
    - np.ndarray: An array of complex numbers representing the detector's response at each frequency in f.
    """
    cdef int nf = f.shape[0]
    cdef double nproj 
    cdef double complex[:] out_ = np.empty(nf, dtype=complex)

    for kk in range(nf):
        nproj = 0
        for jj in range(3):
            nproj += n_vec[kk, jj] * arm_vec[jj]
        out_[kk] = projection_factor(f[kk], nproj, f_fsr)
    return out_

cpdef frequency_dependent_projected_detector_function(double[:] f, double[:] n_vec, double[:] arm_vec, double f_fsr):
    """
    Computes eq. 5 in https://journals.aps.org/prd/pdf/10.1103/PhysRevD.96.084004 by
    projecting n onto the e basis vectors (arms unit vectors). 

    Parameters:
    - f (double[:]): An array of frequencies at which the detector's response is being calculated.
    - n_vec (double[:]): The vector pointing towards the source of the gravitational waves, in the detector's frame.
    - arm_vec (double[:]): The unit vector along the detector's arm, in the detector's frame.
    - f_fsr (double): The free spectral range of the detector

    Returns:
    - np.ndarray: An array of complex numbers representing the detector's response at each frequency in f.
    """
    cdef double nproj 
    cdef int nf = f.shape[0]
    out = np.empty(nf, dtype=complex)
    cdef double complex[:] out_ = out

    nproj = 0
    for jj in range(3):
        nproj += n_vec[jj] * arm_vec[jj]
    for ii in range(nf):
        out_[ii] = projection_factor(f[ii], nproj, f_fsr)
    return out

cpdef projection_factor(double f, double nproj, double fsr):
    """
    Compute the actual projection factor for scalar values of frequency and
    line of sight projection.
    """
    cdef double complex out
    out = fsr/(4*pi*f*1j) * ( (1 - complex_exp(-pi*1j*(1-nproj) * f / fsr))/(1-nproj) -
            complex_exp(-2j*pi*f/fsr) * (1 - complex_exp(pi*1j*(1+nproj) * f / fsr))/(1+nproj)
            )
    return out


cpdef calculate_arm(double arm_tilt, double arm_azimuth, double longitude, double latitude):
    """
    Compute the unit-vector along an interferometer arm given the specified parameters.

    Parameters
    ----------
    arm_tilt: float
        The angle between the tangent to the Earth and the arm
    arm_azimuth: float
        The azimuthal angle of the arm in FIXME
    longitude: float
        The longitude of the vertex
    latitude: float
        The latitude of the vertex

    Returns
    -------
    output: array_like
        The unit-vector pointing along the interferometer arm 

    """
    output = np.empty(3)
    cdef double[:] output_ = output
    cdef double cos_tilt, sin_tilt
    cdef double cos_azimuth, sin_azimuth
    cdef double cos_longitude, sin_longitude
    cdef double cos_latitude, sin_latitude
    cos_tilt = cos(arm_tilt)
    sin_tilt = sin(arm_tilt)
    cos_azimuth = cos(arm_azimuth)
    sin_azimuth = sin(arm_azimuth)
    cos_longitude = cos(longitude)
    sin_longitude = sin(longitude)
    cos_latitude = cos(latitude)
    sin_latitude = sin(latitude)

    output_[0] = (
        - sin_longitude * cos_tilt * cos_azimuth
        - sin_latitude * cos_longitude * cos_tilt * sin_azimuth
        + cos_latitude * cos_longitude * sin_tilt
    )
    output_[1] = (
        cos_longitude * cos_tilt * cos_azimuth
        - sin_latitude * sin_longitude * cos_tilt * sin_azimuth
        + cos_latitude * sin_longitude * sin_tilt
    )
    output_[2] = cos_latitude * cos_tilt * sin_azimuth + sin_latitude * sin_tilt
    return output


cdef euler_rotation(double[:] delta_x, double[:, :] rotation):
    """
    Calculate the rotation matrix mapping the vector (0, 0, 1) to delta_x
    while preserving the origin of the azimuthal angle.

    This is decomposed into three Euler angles, alpha, beta, gamma, which rotate
    about the z-, y-, and z- axes respectively.
    """
    cdef double alpha, gamma, norm
    cdef double cos_alpha, sin_alpha, cos_beta, sin_beta, cos_gamma, sin_gamma

    norm = pow(delta_x[0] * delta_x[0] + delta_x[1] * delta_x[1] + delta_x[2] * delta_x[2], 0.5)
    cos_beta = delta_x[2] / norm
    sin_beta = pow(1 - cos_beta**2, 0.5)

    alpha = atan2(- delta_x[1] * cos_beta, delta_x[0])
    gamma = atan2(delta_x[1], delta_x[0])

    cos_alpha = cos(alpha)
    sin_alpha = sin(alpha)
    cos_gamma = cos(gamma)
    sin_gamma = sin(gamma)

    rotation[0][0] = cos_alpha * cos_beta * cos_gamma - sin_alpha * sin_gamma
    rotation[1][0] = cos_alpha * cos_beta * sin_gamma + sin_alpha * cos_gamma
    rotation[2][0] = -cos_alpha * sin_beta
    rotation[0][1] = -sin_alpha * cos_beta * cos_gamma - cos_alpha * sin_gamma
    rotation[1][1] = -sin_alpha * cos_beta * sin_gamma + cos_alpha * cos_gamma
    rotation[2][1] = sin_alpha * sin_beta
    rotation[0][2] = sin_beta * cos_gamma
    rotation[1][2] = sin_beta * sin_gamma
    rotation[2][2] = cos_beta


cpdef rotation_matrix_from_delta(delta_x):
    """
    Calculate the rotation matrix mapping the vector (0, 0, 1) to delta_x
    while preserving the origin of the azimuthal angle.

    This is decomposed into three Euler angles, alpha, beta, gamma, which rotate
    about the z-, y-, and z- axes respectively.

    Parameters
    ==========
    delta_x: array-like (3,)
        Vector onto which (0, 0, 1) should be mapped.
    rotation: array-like (3,3)

    Returns
    =======
    total_rotation: array-like (3,3)
        Rotation matrix which maps vectors from the frame in which delta_x is
        aligned with the z-axis to the target frame.
    """
    cdef double[:] delta
    cdef double[:, :] rotation_
    rotation = np.empty((3, 3))
    delta = delta_x
    rotation_ = rotation
    euler_rotation(delta, rotation_)
    return rotation


cpdef zenith_azimuth_to_theta_phi(double zenith, double azimuth, np.ndarray delta_x):
    """
    Convert from the 'detector frame' to the Earth frame.

    Parameters
    ==========
    zenith: float
        The zenith angle in the detector frame
    azimuth: float
        The azimuthal angle in the detector frame
    delta_x: array_like
        The separation vector for the two detectors defining the frame

    Returns
    =======
    theta, phi: float
        The zenith and azimuthal angles in the earth frame.
    """
    rotation = np.empty((3, 3))
    cdef double sin_azimuth, cos_azimuth
    cdef double sin_zenith, cos_zenith
    cdef double[:] delta_
    cdef double[:, :] rotation_
    sin_azimuth = sin(azimuth)
    cos_azimuth = cos(azimuth)
    sin_zenith = sin(zenith)
    cos_zenith = cos(zenith)

    delta_ = delta_x
    rotation_ = rotation
    euler_rotation(delta_, rotation_)

    theta = acos(
        rotation_[2][0] * sin_zenith * cos_azimuth
        + rotation_[2][1] * sin_zenith * sin_azimuth
        + rotation_[2][2] * cos_zenith
    )
    phi = fmod(
        atan2(
            rotation_[1][0] * sin_zenith * cos_azimuth
            + rotation_[1][1] * sin_zenith * sin_azimuth
            + rotation_[1][2] * cos_zenith,
            rotation_[0][0] * sin_zenith * cos_azimuth
            + rotation_[0][1] * sin_zenith * sin_azimuth
            + rotation_[0][2] * cos_zenith
        ) + 2 * pi,
        (2 * pi)
    )
    return theta, phi